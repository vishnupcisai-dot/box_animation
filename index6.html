<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>14</title>
    <style>
        * {
            margin: 0;
            overflow: hidden; 
        }
        .text{
            position: absolute;
            color: white;
            width: 100%;
            text-align: center;
            top: 50px;
            font-size: 5vw;
            z-index: 10;
        }
    </style>
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
          }
        }
    </script>
</head>
<div class="text">Box Moving Through 4 Corners (Discrete Loop)</div>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // --- Three.js Setup ---

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a); 
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 20); // Adjust camera to view the movement better
        
        const renderer = new THREE.WebGLRenderer({ antialias: true }); 
        renderer.setAnimationLoop(animate);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement); 
        controls.enableDamping = true; 
        controls.dampingFactor = 0.25;
        

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);


        // --- Geometry and Material ---
        const BOX_GEO = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshPhysicalMaterial({
            color: 0x3498DB, 
            metalness: 0.5,
            roughness: 0.2,
        });
        const box = new THREE.Mesh(BOX_GEO, material);
        scene.add(box);

        
        // --- Animation State Variables ---
        
        // The four corner positions for the box to follow
        const corners = [
            new THREE.Vector3(-9, -9, 0), // 1st position (Bottom-Left)
            new THREE.Vector3(9, -9, 0),  // 2nd position (Bottom-Right)
            new THREE.Vector3(9, 9, 0),  // 3rd position (Top-Right)
            new THREE.Vector3(-9, 9, 0)  // 4th position (Top-Left)
        ];
        // Start the box at the first corner
        box.position.copy(corners[0]);

        let currentCornerIndex = 0; // The index of the *target* corner
        let animationProgress = 0.1;  // Progress (0.0 to 1.0) of the current movement segment
        const animationSpeed = 0.001; // Controls how fast the box moves between corners
        
        // --- Animation Loop ---

        function animate(){
            // We use the renderer's deltaTime or a fixed step for consistent speed
            const deltaTime = 1 / 60; // Assuming 60fps, fixed step is simpler for this logic

            controls.update(); 
            
            // 1. Calculate the next target corner
            const startCorner = corners[currentCornerIndex];
            const nextCornerIndex = (currentCornerIndex + 1) % corners.length; // Loop back to 0
            const endCorner = corners[nextCornerIndex];

            // 2. Update the progress for the current movement segment
            animationProgress += animationSpeed; 

            // 3. Interpolate the position (LERP)
            // LERP stands for Linear Interpolation: moves from startCorner to endCorner based on progress
            box.position.lerpVectors(startCorner, endCorner, animationProgress);

            // 4. Check if the movement is complete (Progress has reached or exceeded 1.0)
            if (animationProgress >= 1.0) {
                // Set the box position exactly to the end corner to avoid cumulative error
                box.position.copy(endCorner);
                
                // Move the start point to the end point for the next segment
                currentCornerIndex = nextCornerIndex; 
                
                // Reset progress
                animationProgress = 0;
            }
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>